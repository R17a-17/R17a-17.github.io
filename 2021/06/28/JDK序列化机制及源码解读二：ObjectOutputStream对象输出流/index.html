<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="这是Java序列化机制及源码解读系列的第二篇，主要学习源码处理对象输出流的方法。接下来会先学习ObjectOutputStream的父类，然后再探究ObjectOutputStream。 12public class ObjectOutputStream    extends OutputStream implements ObjectOutput, ObjectStreamConstants">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK序列化机制及源码解读二：ObjectOutputStream对象输出流">
<meta property="og:url" content="https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/index.html">
<meta property="og:site_name" content="R17a&#39;s blog">
<meta property="og:description" content="这是Java序列化机制及源码解读系列的第二篇，主要学习源码处理对象输出流的方法。接下来会先学习ObjectOutputStream的父类，然后再探究ObjectOutputStream。 12public class ObjectOutputStream    extends OutputStream implements ObjectOutput, ObjectStreamConstants">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://r17a-17.github.io/imgs/image-20210628141109140.png">
<meta property="og:image" content="https://r17a-17.github.io/imgs/image-20210630210013254.png">
<meta property="og:image" content="https://r17a-17.github.io/imgs/writeObject%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="og:image" content="https://r17a-17.github.io/imgs/image-20210701160611733.png">
<meta property="article:published_time" content="2021-06-28T02:45:46.000Z">
<meta property="article:modified_time" content="2021-08-17T02:45:46.000Z">
<meta property="article:author" content="R17a">
<meta property="article:tag" content="JDK序列化机制">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://r17a-17.github.io/imgs/image-20210628141109140.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>JDK序列化机制及源码解读二：ObjectOutputStream对象输出流</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/download/">Download</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/07/01/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B8%89%EF%BC%9AObjectInputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%85%A5%E6%B5%81/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2021/06/27/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B8%80%EF%BC%9ASerializable%E5%92%8CExternalizable/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&text=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&title=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&is_video=false&description=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流" target="_blank" rel="noopener"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流&body=Check out this article: https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&title=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流" target="_blank" rel="noopener"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&title=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流" target="_blank" rel="noopener"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&title=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流" target="_blank" rel="noopener"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&title=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流" target="_blank" rel="noopener"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&name=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&t=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流" target="_blank" rel="noopener"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、DataOutput"><span class="toc-number">1.</span> <span class="toc-text">一、DataOutput</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、ObjectOutput"><span class="toc-number">2.</span> <span class="toc-text">二、ObjectOutput</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、OutputStream"><span class="toc-number">3.</span> <span class="toc-text">三、OutputStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、ObjectStreamConstants"><span class="toc-number">4.</span> <span class="toc-text">四、ObjectStreamConstants</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、ObjectOutputStream"><span class="toc-number">5.</span> <span class="toc-text">五、ObjectOutputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、静态内部类BlockDataOutputStream-Java基本数据类型的写入流实现"><span class="toc-number">5.1.</span> <span class="toc-text">1、静态内部类BlockDataOutputStream-Java基本数据类型的写入流实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1、BlockDataOutputStream构造方法："><span class="toc-number">5.1.1.</span> <span class="toc-text">1.1、BlockDataOutputStream构造方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2、块数据模式及底层流数据写入"><span class="toc-number">5.1.2.</span> <span class="toc-text">1.2、块数据模式及底层流数据写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3、BlockDataOutputStream处理基元数据输出方法："><span class="toc-number">5.1.3.</span> <span class="toc-text">1.3、BlockDataOutputStream处理基元数据输出方法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、序列化导读"><span class="toc-number">5.2.</span> <span class="toc-text">2、序列化导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、ObjectOutputStream构造方法"><span class="toc-number">5.3.</span> <span class="toc-text">3、ObjectOutputStream构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1、有参构造："><span class="toc-number">5.3.1.</span> <span class="toc-text">3.1、有参构造：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2、writeStreamHeader-："><span class="toc-number">5.3.2.</span> <span class="toc-text">3.2、writeStreamHeader()：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、writeObject写入对象输出流"><span class="toc-number">5.4.</span> <span class="toc-text">4、writeObject写入对象输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#writeObject的调用"><span class="toc-number">5.4.1.</span> <span class="toc-text">writeObject的调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1、writeObject："><span class="toc-number">5.4.2.</span> <span class="toc-text">4.1、writeObject：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#writeObject"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">writeObject</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#writeFatalException：处理序列化异常情况下的序列化信息"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">writeFatalException：处理序列化异常情况下的序列化信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#writeObject0："><span class="toc-number">5.4.2.3.</span> <span class="toc-text">writeObject0：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#补充：ObjectStreamClass"><span class="toc-number">5.4.2.4.</span> <span class="toc-text">补充：ObjectStreamClass</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三种类型的序列化-write-String-Array-Enum-："><span class="toc-number">5.4.2.5.</span> <span class="toc-text">三种类型的序列化  write[String|Array|Enum]：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#序列化关键部分writeOrdinaryObject："><span class="toc-number">5.4.2.6.</span> <span class="toc-text">序列化关键部分writeOrdinaryObject：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2、类元信息序列化-writeClassDesc"><span class="toc-number">5.4.3.</span> <span class="toc-text">4.2、类元信息序列化 writeClassDesc()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#writeClassDesc-序列化类信息："><span class="toc-number">5.4.3.1.</span> <span class="toc-text">writeClassDesc-序列化类信息：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ObjectStreamClass-writeNonProxy：写入实际的类元信息"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">ObjectStreamClass#writeNonProxy：写入实际的类元信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#补充：ObjectStreamField"><span class="toc-number">5.4.3.3.</span> <span class="toc-text">补充：ObjectStreamField</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3、类实例数据信息序列化writeExternalData-writeSerialData"><span class="toc-number">5.4.4.</span> <span class="toc-text">4.3、类实例数据信息序列化writeExternalData&#x2F; writeSerialData</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#writeSerialData-amp-writeExternalData："><span class="toc-number">5.4.4.1.</span> <span class="toc-text">writeSerialData&amp;writeExternalData：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#属性值信息序列化的关键-默认属性值序列化方法defaultWriteFields"><span class="toc-number">5.4.4.2.</span> <span class="toc-text">属性值信息序列化的关键-默认属性值序列化方法defaultWriteFields:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六、总结-对象流输出规则"><span class="toc-number">5.5.</span> <span class="toc-text">六、总结-对象流输出规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新-defaultWriteObject"><span class="toc-number">5.6.</span> <span class="toc-text">更新-defaultWriteObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考："><span class="toc-number">5.7.</span> <span class="toc-text">参考：</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        JDK序列化机制及源码解读二：ObjectOutputStream对象输出流
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">R17a</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-06-28T02:45:46.000Z" itemprop="datePublished">2021-06-28</time>
        
        (Updated: <time datetime="2021-08-17T02:45:46.000Z" itemprop="dateModified">2021-08-17</time>)
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/JAVA%E5%AE%89%E5%85%A8/">JAVA安全</a> › <a class="category-link" href="/categories/JAVA%E5%AE%89%E5%85%A8/%E5%BA%8F%E5%88%97%E5%8C%96/">序列化</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/" rel="tag">JDK序列化机制</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>这是Java序列化机制及源码解读系列的第二篇，主要学习源码处理对象输出流的方法。接下来会先学习ObjectOutputStream的父类，然后再探究ObjectOutputStream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectOutputStream</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">OutputStream</span> <span class="keyword">implements</span> <span class="title">ObjectOutput</span>, <span class="title">ObjectStreamConstants</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/imgs/image-20210628141109140.png" alt="ObjectOutputStream UML图"></p>
<p>学习ObjectOutputStream前，先了解下其父类。</p>
<h2 id="一、DataOutput"><a href="#一、DataOutput" class="headerlink" title="一、DataOutput"></a>一、DataOutput</h2><p>DataOutput接口提供将数据从任何Java基本类型（byte、short、int、long、float、double、char、boolean）转换为一系列字节，并将这些字节写入二进制流。  还有一种将<code>String</code>转换为modified UTF-8格式并编写结果字节系列的功能。 </p>
<p>DataOutput定义了以下接口方法：</p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td>write(byte[] b)：将输出流写入数组 b中的所有字节。</td>
</tr>
<tr>
<td>void</td>
<td>write(byte[] b, int off, int len)：从阵列 b写入 len字节，以输出流。</td>
</tr>
<tr>
<td>void</td>
<td>write(int b)：向输出流写入参数 b的八个低位。</td>
</tr>
<tr>
<td>void</td>
<td>writeBoolean(boolean v)：将 boolean值写入此输出流。</td>
</tr>
<tr>
<td>void</td>
<td>writeByte(int v)：向输出流写入参数 v的八个低位位。</td>
</tr>
<tr>
<td>void</td>
<td>writeBytes(String s)：将一个字符串写入输出流。</td>
</tr>
<tr>
<td>void</td>
<td>writeChar(int v)：将两个字节组成的 char值写入输出流。</td>
</tr>
<tr>
<td>void</td>
<td>writeChars(String s)：写入每一个字符在字符串中 s ，到输出流中，为了，每个字符使用两个字节。</td>
</tr>
<tr>
<td>void</td>
<td>writeDouble(double v)：将 double值（由8个字节组成）写入输出流。</td>
</tr>
<tr>
<td>void</td>
<td>writeFloat(float v)：将 float值写入输出流，该值由四个字节组成。</td>
</tr>
<tr>
<td>void</td>
<td>writeInt(int v)：将 int值（由四个字节组成）写入输出流。</td>
</tr>
<tr>
<td>void</td>
<td>writeLong(long v)：将 long值（由八个字节组成）写入输出流。</td>
</tr>
<tr>
<td>void</td>
<td>writeShort(int v)：将两个字节写入输出流以表示参数的值。</td>
</tr>
<tr>
<td>void</td>
<td>writeUTF(String s)：将两个字节的长度信息写入输出流，其后是 字符串 s中每个字符的 s 。</td>
</tr>
</tbody></table>
<h2 id="二、ObjectOutput"><a href="#二、ObjectOutput" class="headerlink" title="二、ObjectOutput"></a>二、ObjectOutput</h2><p>ObjectOutput扩展了DataOutput接口，除了原始类型外还添加了对象、数组和字符串的输出流。</p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td>close():关闭流。</td>
</tr>
<tr>
<td>void</td>
<td>flush():刷新流。</td>
</tr>
<tr>
<td>void</td>
<td>write(byte[] b):写入一个字节数组。</td>
</tr>
<tr>
<td>void</td>
<td>write(byte[] b, int off, int len):写入一个子字节数组。</td>
</tr>
<tr>
<td>void</td>
<td>write(int b):写一个字节。</td>
</tr>
<tr>
<td>void</td>
<td>writeObject(Object obj):将对象写入底层存储或流。</td>
</tr>
</tbody></table>
<h2 id="三、OutputStream"><a href="#三、OutputStream" class="headerlink" title="三、OutputStream"></a>三、OutputStream</h2><p>这个抽象类是表示字节输出流的所有类的超类。输出流接收输出字节并将其发送到某个接收器。</p>
<p>需要定义<code>OutputStream</code>子类的应用<code>OutputStream</code>必须至少提供一个写入一个字节输出的方法。 </p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td>close():关闭此输出流并释放与此流相关联的任何系统资源。</td>
</tr>
<tr>
<td>void</td>
<td>flush():刷新此输出流并强制任何缓冲的输出字节被写出。</td>
</tr>
<tr>
<td>void</td>
<td>write(byte[] b):将 b.length字节从指定的字节数组写入此输出流。</td>
</tr>
<tr>
<td>void</td>
<td>write(byte[] b, int off, int len):从指定的字节数组写入 len个字节，从偏移 off开始输出到此输出流。</td>
</tr>
<tr>
<td>void</td>
<td>write(int b):将指定的字节写入此输出流。</td>
</tr>
<tr>
<td>void</td>
<td>writeObject(Object obj):将对象写入底层存储或流。</td>
</tr>
</tbody></table>
<h2 id="四、ObjectStreamConstants"><a href="#四、ObjectStreamConstants" class="headerlink" title="四、ObjectStreamConstants"></a>四、ObjectStreamConstants</h2><p>ObjectStreamConstants定义了一系列的常量，用来表示对象进行序列化时单个字节数据的含义，方便后续序列化和反序列化按照此规范进行。</p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Field</th>
<th>Description</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>static short</td>
<td>STREAM_MAGIC</td>
<td>魔术头，标记序列化协议的信息</td>
<td>0xaced</td>
</tr>
<tr>
<td>static short</td>
<td>STREAM_VERSION</td>
<td>标记序列化协议的版本信息</td>
<td>0x0005</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_BASE</td>
<td>第一个标签值</td>
<td>0x70</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_NULL</td>
<td>Null对象引用,父类描述符标识</td>
<td>0x70</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_REFERENCE</td>
<td>流中已存在对象的引用</td>
<td>0x71</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_CLASSDESC</td>
<td>new class类描述符</td>
<td>0x72</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_OBJECT</td>
<td>new 对象</td>
<td>0x73</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_STRING</td>
<td>new String字符串</td>
<td>0x74</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_ARRAY</td>
<td>new 数组</td>
<td>0x75</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_CLASS</td>
<td>类引用</td>
<td>0x76</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_BLOCKDATA</td>
<td>字节跟随标记表示此块数据中的字节数</td>
<td>0x77</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_ENDBLOCKDATA</td>
<td>一个对象的可选数据块的结尾</td>
<td>0x78</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_RESET</td>
<td>重置流上下文</td>
<td>0x79</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_BLOCKDATALONG</td>
<td>long类型数据块，标记long类型数据块的数量</td>
<td>0x7A</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_EXCEPTION</td>
<td>写过程发生异常</td>
<td>0x7B</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_LONGSTRING</td>
<td>long字符串</td>
<td>0x7C</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_PROXYCLASSDESC</td>
<td>new 代理类描述符</td>
<td>0x7D</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_ENUM</td>
<td>new 枚举常量</td>
<td>0x7E</td>
</tr>
<tr>
<td>static byte</td>
<td>TC_MAX</td>
<td>最后一个标签值</td>
<td>0x7E</td>
</tr>
<tr>
<td>static int</td>
<td>baseWireHandle</td>
<td>分配的第一个句柄</td>
<td>0x7e0000</td>
</tr>
<tr>
<td>static byte</td>
<td>SC_WRITE_METHOD</td>
<td>对于objectstreamclass标志位屏蔽。表示一个可序列化的类自定义了writeObject()</td>
<td>0x01</td>
</tr>
<tr>
<td>static byte</td>
<td>SC_SERIALIZABLE</td>
<td>对于objectstreamclass标志位屏蔽。显示类的序列化，实现Serializable</td>
<td>0x02</td>
</tr>
<tr>
<td>static byte</td>
<td>SC_EXTERNALIZABLE</td>
<td>对于objectstreamclass标志位屏蔽。指示类是外部的，实现Externalizable</td>
<td>0x04</td>
</tr>
<tr>
<td>static byte</td>
<td>SC_BLOCK_DATA</td>
<td>对于objectstreamclass标志位屏蔽。说明写的块数据模式的外部数据</td>
<td>0x08</td>
</tr>
<tr>
<td>static byte</td>
<td>SC_ENUM</td>
<td>对于objectstreamclass标志位屏蔽。指出类是一个枚举类型，Enum</td>
<td>0x10</td>
</tr>
<tr>
<td>static int</td>
<td>PROTOCOL_VERSION_1</td>
<td>流协议的版本</td>
<td>0x0001</td>
</tr>
<tr>
<td>static int</td>
<td>PROTOCOL_VERSION_2</td>
<td>流协议的版本</td>
<td>0x0002</td>
</tr>
<tr>
<td>static SerializablePermission</td>
<td>SUBCLASS_IMPLEMENTATION_PERMISSION</td>
<td>允许重写 readObject 和 writeObject</td>
<td>new SerializablePermission(“enableSubclassImplementation”);</td>
</tr>
<tr>
<td>static SerializablePermission</td>
<td>SUBSTITUTION_PERMISSION</td>
<td>允许在序列化/反序列化期间使用一个对象取代另一个对象。</td>
<td>new SerializablePermission(“enableSubstitution”);</td>
</tr>
</tbody></table>
<h2 id="五、ObjectOutputStream"><a href="#五、ObjectOutputStream" class="headerlink" title="五、ObjectOutputStream"></a>五、ObjectOutputStream</h2><p>ObjectOutStream有7个内部类，其作用如下：</p>
<ol>
<li>BlockDataOutputStream Java基本数据类型的写入流实现</li>
<li>Caches 用于安全审计缓存</li>
<li>DebugTraceInfoStack 堆栈保存有关序列化进程状态的调试信息，以便嵌入异常消息</li>
<li>HandleTable 保存对象及其句柄的映射关系 作用是缓存写过的共享class便于下次查找</li>
<li>ReplaceTable 替换对象的映射关系</li>
<li>PutField和PutFieldImpl 动态修改序列化的字段</li>
</ol>
<p>先着重分析下BlockDataOutputStream，再分析ObjectOutputStream的方法及序列化流程。</p>
<h3 id="1、静态内部类BlockDataOutputStream-Java基本数据类型的写入流实现"><a href="#1、静态内部类BlockDataOutputStream-Java基本数据类型的写入流实现" class="headerlink" title="1、静态内部类BlockDataOutputStream-Java基本数据类型的写入流实现"></a>1、静态内部类BlockDataOutputStream-Java基本数据类型的写入流实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockDataOutputStream</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">OutputStream</span> <span class="keyword">implements</span> <span class="title">DataOutput</span></span></span><br></pre></td></tr></table></figure>

<p>BlockDataOutputStream实现了DataOutput并且继承了OutputStream，该类主要用来将数据从Java基本类型转换字节流并写入底层数据流。</p>
<p>缓冲输出流有两种模式：在默认模式下，输出数据和DataOutputStream使用同样模式；在块数据模式下，使用一个缓冲区来缓存数据到达最大长度或者手动刷新时将内容写入底层数据流，块模式在写数据之前，要先写入一个头部来表示当前块的长度。</p>
<p>从内部变量和构造函数中可以看出，缓冲区的大小是固定且不可修改的，其中包含了一个下层输入流和一个数据输出流以及是否采用块模式的标识，在构造时默认不采用块数据模式。</p>
<h4 id="1-1、BlockDataOutputStream构造方法："><a href="#1-1、BlockDataOutputStream构造方法：" class="headerlink" title="1.1、BlockDataOutputStream构造方法："></a>1.1、BlockDataOutputStream构造方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockDataOutputStream</span> <span class="keyword">extends</span> <span class="title">OutputStream</span> <span class="keyword">implements</span> <span class="title">DataOutput</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">/** maximum data block length */</span></span><br><span class="line">        <span class="comment">// 缓冲数据块长度1024</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_BLOCK_SIZE = <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">/** maximum data block header length */</span> </span><br><span class="line">        <span class="comment">// 头部最大长度5</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HEADER_SIZE = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">/** (tunable) length of char buffer (for writing strings) */</span></span><br><span class="line">        <span class="comment">// 针对string类型 ：char字符缓冲块长度256</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHAR_BUF_SIZE = <span class="number">256</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">/** buffer for writing general/block data */</span></span><br><span class="line">    	<span class="comment">// 字节数据块缓冲区</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[MAX_BLOCK_SIZE];</span><br><span class="line">        <span class="comment">/** buffer for writing block data headers */</span></span><br><span class="line">    	<span class="comment">// 头部缓冲区</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] hbuf = <span class="keyword">new</span> <span class="keyword">byte</span>[MAX_HEADER_SIZE];</span><br><span class="line">        <span class="comment">/** char buffer for fast string writes */</span></span><br><span class="line">    	<span class="comment">// 字符数据缓冲区</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[CHAR_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** block data mode */</span></span><br><span class="line">    	<span class="comment">// 块数据模式，默认关闭</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> blkmode = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/** current offset into buf */</span></span><br><span class="line">    	<span class="comment">// 在字节数据缓冲区的当前偏移量，初始为0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** underlying output stream */</span></span><br><span class="line">    	<span class="comment">// 底层数据流</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> OutputStream out;</span><br><span class="line">        <span class="comment">/** loopback stream (for data writes that span data blocks) */</span></span><br><span class="line">    	<span class="comment">// 回路流用于写跨越数据块的数据</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> DataOutputStream dout;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在底层流上创建一个BlockDataOutputStream，块数据模式默认关闭</span></span><br><span class="line">        BlockDataOutputStream(OutputStream out) &#123;</span><br><span class="line">            <span class="keyword">this</span>.out = out;</span><br><span class="line">            dout = <span class="keyword">new</span> DataOutputStream(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2、块数据模式及底层流数据写入"><a href="#1-2、块数据模式及底层流数据写入" class="headerlink" title="1.2、块数据模式及底层流数据写入"></a>1.2、块数据模式及底层流数据写入</h4><p>BlockDataOutputStream定义了两个方法用于设置和获取块数据模式：setBlockDataMode可以改变当前的数据模式，从块数据模式切换到非块数据模式时，要将缓冲区内的数据写入到底层流；getBlockDataMode查询当前块数据模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置块数据模式为给出的模式true是开启，false是关闭，并返回之前的模式值。</span></span><br><span class="line"><span class="comment"> * 如果新的模式和旧的一样，什么都不做。</span></span><br><span class="line"><span class="comment"> * 如果新的模式和旧的模式不同，所有的缓冲区数据要在转换到新模式之前刷新。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">setBlockDataMode</span><span class="params">(<span class="keyword">boolean</span> mode)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blkmode == mode) &#123;</span><br><span class="line">        <span class="keyword">return</span> blkmode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将缓冲区内的数据全部写入底层流</span></span><br><span class="line">    drain();</span><br><span class="line">    blkmode = mode;</span><br><span class="line">    <span class="keyword">return</span> !blkmode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前流为块数据模式返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getBlockDataMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blkmode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>drain在多个方法中被调用，作用是将<strong>缓冲区内的数据全部写入底层流</strong>，但不会刷新底层流，在写入实际数据前要先用writeBlockHeader写入块头部，头部包含1字节标识位和1字节或4字节的长度大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将缓冲数据写入到底层流，但是不刷新底层流</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 空缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 块数据模式头部数据写入</span></span><br><span class="line">    <span class="keyword">if</span> (blkmode) &#123;</span><br><span class="line">        writeBlockHeader(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入缓冲区数据</span></span><br><span class="line">    out.write(buf, <span class="number">0</span>, pos);</span><br><span class="line">    <span class="comment">// 重置缓冲区偏移</span></span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写块数据的头部信息，数据块少于256字节 头部写入2个字节，多于256字节则写入5个字节的头部</span></span><br><span class="line"><span class="comment">// 因为255字节以内可以用1字节来表示长度，4字节可以表示int范围内的最大整数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeBlockHeader</span><span class="params">(<span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 小于256，TC_BLOCKDATA 0x77标记字节跟随标记表示此块数据中的字节数</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0xFF</span>) &#123;</span><br><span class="line">        hbuf[<span class="number">0</span>] = TC_BLOCKDATA;</span><br><span class="line">        hbuf[<span class="number">1</span>] = (<span class="keyword">byte</span>) len;</span><br><span class="line">        out.write(hbuf, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 大于255，TC_BLOCKDATALONG 0x7A标记long类型数据块</span></span><br><span class="line">        hbuf[<span class="number">0</span>] = TC_BLOCKDATALONG;</span><br><span class="line">        Bits.putInt(hbuf, <span class="number">1</span>, len);</span><br><span class="line">        out.write(hbuf, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通用数据流写入的处理方法：<strong>write主要是写入到缓冲区</strong>，写入前都需要先检查缓冲区有没有达到上限，达到时需要先刷新，然后再将数据复制到缓冲区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ----------------- 通用数据流处理方法 ----------------- */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 下面的方法 除了在参与块数据模式下写入数据到数据块中的部分有所不同</span></span><br><span class="line"><span class="comment"> * 其它都等价于他们在OutputStream中的对应方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储一个字节的数据到缓冲区，如果缓冲区满了先刷新缓冲区写入底层流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 达到缓冲区上限，将缓冲区内的数据全部写入底层流</span></span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= MAX_BLOCK_SIZE) &#123;</span><br><span class="line">        drain();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储一个字节的数据到缓冲区</span></span><br><span class="line">    buf[pos++] = (<span class="keyword">byte</span>) b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    write(b, <span class="number">0</span>, b.length, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    write(b, off, len, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从给定数组写入指定的字节值范围。如果copy为true，则在将值写入底层流之前将其复制到中间缓冲区(以避免暴露对原始字节数组的引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">boolean</span> copy)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 非copy模式也非块数据模式直接将数据写入底层流</span></span><br><span class="line">    <span class="keyword">if</span> (!(copy || blkmode)) &#123;</span><br><span class="line">        drain();</span><br><span class="line">        out.write(b, off, len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 达到缓冲区上限，将缓冲区内的数据全部写入底层流</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= MAX_BLOCK_SIZE) &#123;</span><br><span class="line">            drain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len &gt;= MAX_BLOCK_SIZE &amp;&amp; !copy &amp;&amp; pos == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 长度大于缓冲区 非copy模式 且缓冲区为空直接写，避免不必要的复制</span></span><br><span class="line">            writeBlockHeader(MAX_BLOCK_SIZE);</span><br><span class="line">            out.write(b, off, MAX_BLOCK_SIZE);</span><br><span class="line">            off += MAX_BLOCK_SIZE;</span><br><span class="line">            len -= MAX_BLOCK_SIZE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 剩余内容在缓冲区内放得下 或者缓冲区不为空 或者是copy模式，则将数据复制到缓冲区</span></span><br><span class="line">            <span class="keyword">int</span> wlen = Math.min(len, MAX_BLOCK_SIZE - pos);</span><br><span class="line">            System.arraycopy(b, off, buf, pos, wlen);</span><br><span class="line">            pos += wlen;</span><br><span class="line">            off += wlen;</span><br><span class="line">            len -= wlen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新缓冲区并且刷新底层流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    drain();</span><br><span class="line">    out.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//刷新后关闭流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3、BlockDataOutputStream处理基元数据输出方法："><a href="#1-3、BlockDataOutputStream处理基元数据输出方法：" class="headerlink" title="1.3、BlockDataOutputStream处理基元数据输出方法："></a>1.3、BlockDataOutputStream处理基元数据输出方法：</h4><p>剩余写不同基元数据的方法到缓冲区都类似，write[Type]和write[Type]s一个是处理单个基元数据和一组连续基元数据的情况，write[Type]s相对来说更加优化，以便更有效地写入一组基元数据值或者处理写基元类型的数组，其优化的方式是先计算出缓冲区内的剩余大小，计算可以写入的个数，然后直接写入而不是每次写入之前检查缓冲区是否有空间，减少判断次数。</p>
<p>下面以writeInt和writeInts对Int类型的写入方法深入探究下，其它方法类似不再赘诉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ----------------- 基元数据输出方法 ----------------- */</span></span><br><span class="line"><span class="comment">// 基元数据输出方法方法与DataOutputStream中的对应方法等效，只是在块数据模式下，它们将写入的数据写入缓冲区。基本上逻辑都是先检查空间是否足够，不足的话先刷新缓冲区，然后将数据存储到缓冲区中。写一个字符串时，需要先将字符串中的字符存储到字符缓冲数组中，然后再转换成字节存储到buf中。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//先检查缓冲区是否达到上限，注意一个Int值占4个字节</span></span><br><span class="line">    <span class="keyword">if</span> (pos + <span class="number">4</span> &lt;= MAX_BLOCK_SIZE) &#123;</span><br><span class="line">        <span class="comment">// Bits.putInt将Int值转为字节存储到字节缓冲区</span></span><br><span class="line">        Bits.putInt(buf, pos, v);</span><br><span class="line">        pos += <span class="number">4</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// DataOutputStream.writeInt达到缓冲区将int作为4个字节写入底层输出流</span></span><br><span class="line">        dout.writeInt(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------- 连续多个基元数据输出方法 -------------- */</span></span><br><span class="line"><span class="comment">//下面的方法写出基元数据值的范围。虽然相当于重复调用相应的基元写方法，但这些方法都经过了重新优化，以便更有效地写入一组基元数据值。</span></span><br><span class="line"><span class="comment">//优化的方式是先计算出缓冲区内的剩余大小，计算可以写入的个数，然后直接写入而不是每次写入之前检查缓冲区是否有空间，减少判断次数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeInts</span><span class="params">(<span class="keyword">int</span>[] v, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 缓冲区上限</span></span><br><span class="line">    <span class="keyword">int</span> limit = MAX_BLOCK_SIZE - <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 基元数据值的范围，最终偏移位置</span></span><br><span class="line">    <span class="keyword">int</span> endoff = off + len;</span><br><span class="line">    <span class="comment">// 连续写入多个int数据</span></span><br><span class="line">    <span class="keyword">while</span> (off &lt; endoff) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= limit) &#123;</span><br><span class="line">            <span class="comment">// 除以2的2次方，int是4个字节，所以除以4，计算缓冲区剩余有效int的个数</span></span><br><span class="line">            <span class="keyword">int</span> avail = (MAX_BLOCK_SIZE - pos) &gt;&gt; <span class="number">2</span>; </span><br><span class="line">            <span class="comment">// 比较最终偏移位置和当前偏移位置+缓冲区剩余有效int个数 取最小值</span></span><br><span class="line">            <span class="keyword">int</span> stop = Math.min(endoff, off + avail); </span><br><span class="line">            <span class="keyword">while</span> (off &lt; stop) &#123;</span><br><span class="line">                <span class="comment">// 未达缓冲区上限，连续存储数据到缓冲区，减少了判断缓冲区是否满的次数</span></span><br><span class="line">                <span class="comment">// Bits.putInt将int类型转为字节存储到字节缓冲区</span></span><br><span class="line">                Bits.putInt(buf, pos, v[off++]);</span><br><span class="line">                pos += <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 达到缓冲区上限</span></span><br><span class="line">            <span class="comment">// DataOutputStream.writeInt用于将int数据作为4个字节写入底层输出流，高字节优先</span></span><br><span class="line">            dout.writeInt(v[off++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了write[Type]和write[Type]s，还有writeUTF 写UTF8格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以UTF格式写入给定的字符串。此方法用于字符串的UTF编码长度已经已知的情况;显式地指定它可以避免对字符串进行预扫描以确定其UTF长度。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String s, <span class="keyword">long</span> utflen)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (utflen &gt; <span class="number">0xFFFFL</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写字符串长度，两个字节</span></span><br><span class="line">    writeShort((<span class="keyword">int</span>) utflen);</span><br><span class="line">    <span class="keyword">if</span> (utflen == (<span class="keyword">long</span>) s.length()) &#123;</span><br><span class="line">        <span class="comment">// 如果要写入的长度就是字符串s的长度，直接用writeBytes(s)写入</span></span><br><span class="line">        writeBytes(s);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则 用writeUTFBody写入</span></span><br><span class="line">        writeUTFBody(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、序列化导读"><a href="#2、序列化导读" class="headerlink" title="2、序列化导读"></a>2、序列化导读</h3><p>在开始分析writeObject前，再来强调下，Java序列化时只能序列化该对象的类信息、属性及其值，<strong>不能序列化对象的方法</strong>，JAVA序列化了类信息以后也就可以通过类调用其方法了。所以最终writeObject序列化后的结果一定是类信息和属性的序列化。</p>
<p>为了方便后面writeObject的分析，先看下一个序列化的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要序列化的类必须实现Serializable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSerializable</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 设置serialVersionUID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6211228684695072792L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> intField = <span class="number">112</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> boolField = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">short</span> shortField = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">private</span> String stringField = <span class="string">"stringvalue"</span>;</span><br><span class="line">    <span class="keyword">private</span> File fileField = <span class="keyword">new</span> File(<span class="string">"E:\\"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任意方法，可忽略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化测试：这里只有序列化，不测试反序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/* 序列化对象：由对象转为字节流 */</span></span><br><span class="line">        TestSerializable testSerializable = <span class="keyword">new</span> TestSerializable();</span><br><span class="line">        <span class="comment">//创建 ObjectOutputStream 对象输出流，最终输出流到文件</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"e:\\test.txt"</span>)));</span><br><span class="line">        <span class="comment">//写入对象到输出流</span></span><br><span class="line">        oos.writeObject(testSerializable);</span><br><span class="line">        System.out.println(<span class="string">"对象序列化成功！"</span>);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化后的文件输出结果如下图:</p>
<p><img src="/imgs/image-20210630210013254.png" alt="image-20210630210013254"></p>
<p>虽然序列化后的信息看起来比较乱，但是还是能得到一些信息的</p>
<ul>
<li>类的全称<code>serial.TestSerializable</code></li>
<li>属性类型及属性名和<code>Z</code>和<code>boolField</code>（Z代表boolean类型，后续会提到）</li>
<li>属性类型及属性名<code>I</code>和<code>intField</code>（I代表Int类型，后续会提到）</li>
<li>属性类型及属性名<code>S</code>和<code>shortField</code>（S代表short类型，后续会提到）</li>
<li>属性名及属性类型<code>fileField</code>和<code>java/io/File</code></li>
<li>属性名及属性类型<code>stringField</code>和<code>java/lang/String</code></li>
<li>属性值<code>E:\</code>和<code>stringvalue</code>（当然还有其他值这里只说能看到的）</li>
</ul>
<p>备注：后续分析时会将上面例子带入分析，以<code>（例子分析：）</code>形式备注在每一段分析的最后面。</p>
<h3 id="3、ObjectOutputStream构造方法"><a href="#3、ObjectOutputStream构造方法" class="headerlink" title="3、ObjectOutputStream构造方法"></a>3、ObjectOutputStream构造方法</h3><h4 id="3-1、有参构造："><a href="#3-1、有参构造：" class="headerlink" title="3.1、有参构造："></a>3.1、有参构造：</h4><p>首先把bout绑定到底层的字节数据容器，调用writeStreamHeader()方法完成序列化流头部信息的写入<code>0xaced0005</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectOutputStream</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    verifySubclass();</span><br><span class="line">    <span class="comment">// 创建一个块数据输出流</span></span><br><span class="line">    bout = <span class="keyword">new</span> BlockDataOutputStream(out);</span><br><span class="line">    <span class="comment">// 创建一个HandleTable和ReplaceTable</span></span><br><span class="line">    handles = <span class="keyword">new</span> HandleTable(<span class="number">10</span>, (<span class="keyword">float</span>) <span class="number">3.00</span>);</span><br><span class="line">    subs = <span class="keyword">new</span> ReplaceTable(<span class="number">10</span>, (<span class="keyword">float</span>) <span class="number">3.00</span>);</span><br><span class="line">    <span class="comment">// Override标识</span></span><br><span class="line">    enableOverride = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 写入流数据头</span></span><br><span class="line">    writeStreamHeader();</span><br><span class="line">    <span class="comment">// 启用块数据模式</span></span><br><span class="line">    bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        <span class="comment">//创建异常处理</span></span><br><span class="line">        debugInfoStack = <span class="keyword">new</span> DebugTraceInfoStack();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        debugInfoStack = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2、writeStreamHeader-："><a href="#3-2、writeStreamHeader-：" class="headerlink" title="3.2、writeStreamHeader()："></a>3.2、writeStreamHeader()：</h4><p>写入魔术头和版本信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeStreamHeader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// ObjectStreamConstants定义的常量</span></span><br><span class="line">    bout.writeShort(STREAM_MAGIC); <span class="comment">// ac ed</span></span><br><span class="line">    bout.writeShort(STREAM_VERSION); <span class="comment">// 00 05</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（例子分析：此时上面的例子写入了<code>ac ed 00 05</code>）</p>
<h3 id="4、writeObject写入对象输出流"><a href="#4、writeObject写入对象输出流" class="headerlink" title="4、writeObject写入对象输出流"></a>4、writeObject写入对象输出流</h3><h4 id="writeObject的调用"><a href="#writeObject的调用" class="headerlink" title="writeObject的调用"></a>writeObject的调用</h4><p><img src="/imgs/writeObject%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="writeObject的调用"></p>
<h4 id="4-1、writeObject："><a href="#4-1、writeObject：" class="headerlink" title="4.1、writeObject："></a>4.1、writeObject：</h4><h5 id="writeObject"><a href="#writeObject" class="headerlink" title="writeObject"></a>writeObject</h5><p>如果writeObject被重写会调用writeObjectOverride重写方法，否则调用 writeObject0方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">//if true, invoke writeObjectOverride() instead of writeObject()</span></span><br><span class="line">    <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">        <span class="comment">//如果流子类重写了writeObject则调用writeObjectOverride</span></span><br><span class="line">        writeObjectOverride(obj);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//其它情况则调用writeObject0</span></span><br><span class="line">        writeObject0(obj, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果序列化出现异常调用 writeFatalException 方法</span></span><br><span class="line">            writeFatalException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="writeFatalException：处理序列化异常情况下的序列化信息"><a href="#writeFatalException：处理序列化异常情况下的序列化信息" class="headerlink" title="writeFatalException：处理序列化异常情况下的序列化信息"></a>writeFatalException：处理序列化异常情况下的序列化信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试写入导致序列化中止的致命IOException信息到底层流。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeFatalException</span><span class="params">(IOException ex)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    clear();</span><br><span class="line">    <span class="comment">// 关闭块数据模式</span></span><br><span class="line">    <span class="keyword">boolean</span> oldMode = bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将异常标识TC_EXCEPTION 0x7B写入底层流</span></span><br><span class="line">        bout.writeByte(TC_EXCEPTION);</span><br><span class="line">        <span class="comment">// 将IOException异常对象序列化</span></span><br><span class="line">        writeObject0(ex, <span class="keyword">false</span>);</span><br><span class="line">        clear();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//重启块数据模式</span></span><br><span class="line">        bout.setBlockDataMode(oldMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="writeObject0："><a href="#writeObject0：" class="headerlink" title="writeObject0："></a>writeObject0：</h5><p>序列化的核心方法，主要有三个步骤，1是处理不需要序列化的情况、2是判断是否替换了对象(有writeReplace方法)、3是处理其它情况 主要是String|Array|Enum和一般可序列化对象的序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//关闭块数据模式</span></span><br><span class="line">        <span class="keyword">boolean</span> oldMode = bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">    	<span class="comment">// 递归深度，表示writeObject0被调用的深度</span></span><br><span class="line">    	<span class="comment">// 比如序列化 A 对象时调用 writeObject 则 depth++，而 A 对象的字段又是一个对象，此时又会递归调用 writeObject 方法，当 writeObject 方法执行完成时 depth--。因而如果不出异常则 depth 最终会是 0，有异常则在 catch 模块时 depth 不为 0。</span></span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// handle previously written and non-replaceable objects</span></span><br><span class="line">            <span class="keyword">int</span> h;</span><br><span class="line">            <span class="comment">/**** 1、 不需要序列化的情况 ***/</span></span><br><span class="line">            <span class="keyword">if</span> ((obj = subs.lookup(obj)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//替换后的对象为 null</span></span><br><span class="line">                writeNull();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//handles存储的是已经序列化的对象句柄，如果找到了，直接写一个句柄就可以了</span></span><br><span class="line">                writeHandle(h);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                <span class="comment">//Class对象</span></span><br><span class="line">                writeClass((Class) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">                <span class="comment">//ObjectStreamClass 序列化类的描述信息</span></span><br><span class="line">                writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*** 2、判断是否替换了对象 ***/</span></span><br><span class="line">            Object orig = obj;</span><br><span class="line">            <span class="comment">// 获取要序列化的对象的Class对象</span></span><br><span class="line">            Class&lt;?&gt; cl = obj.getClass();</span><br><span class="line">            <span class="comment">// 创建一个类的序列化描述符对象。 </span></span><br><span class="line">            ObjectStreamClass desc;</span><br><span class="line">            <span class="comment">// 1. 如果要序列化的对象中有 writeReplace 方法，则递归检查最终要输出的对象</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// REMIND: skip this check for strings/arrays?</span></span><br><span class="line">                Class&lt;?&gt; repCl;</span><br><span class="line">                <span class="comment">// 创建描述序列化对象Class的ObjectStreamClass对象</span></span><br><span class="line">                desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// 如果要序列化的对象中有 writeReplace 方法，则递归检查最终要输出的对象</span></span><br><span class="line">                <span class="keyword">if</span> (!desc.hasWriteReplaceMethod() ||</span><br><span class="line">                    (obj = desc.invokeWriteReplace(obj)) == <span class="keyword">null</span> ||</span><br><span class="line">                    (repCl = obj.getClass()) == cl)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cl = repCl;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 子类重写了replaceObject方法</span></span><br><span class="line">            <span class="keyword">if</span> (enableReplace) &#123;</span><br><span class="line">                <span class="comment">//enableReplace和写入时替换对象writeReplace方法有关，如果自定义writeReplace，则调用replaceObject</span></span><br><span class="line">                Object rep = replaceObject(obj);</span><br><span class="line">                <span class="keyword">if</span> (rep != obj &amp;&amp; rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cl = rep.getClass();</span><br><span class="line">                    desc = ObjectStreamClass.lookup(cl, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                obj = rep;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if object replaced, run through original checks a second time</span></span><br><span class="line">            <span class="comment">// 既然要序列化的对象已经被替换了，此时就需要再次做判断，和步骤1类似</span></span><br><span class="line">            <span class="keyword">if</span> (obj != orig) &#123;</span><br><span class="line">                subs.assign(orig, obj);</span><br><span class="line">                <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    writeNull();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (h = handles.lookup(obj)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    writeHandle(h);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                    writeClass((Class) obj, unshared);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectStreamClass) &#123;</span><br><span class="line">                    writeClassDesc((ObjectStreamClass) obj, unshared);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// remaining cases</span></span><br><span class="line">            <span class="comment">//*** 3、处理其余情况：String、Array、Enum及实现了Serializable的对象的写入输出流 ***/</span></span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                writeString((String) obj, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">                writeArray(obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">                writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">                <span class="comment">// 处理Serializable接口的普通对象</span></span><br><span class="line">                writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有实现Serializable接口会抛出 NotSerializableException异常</span></span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">                        cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            depth--;</span><br><span class="line">            <span class="comment">//刷新块数据模式</span></span><br><span class="line">            bout.setBlockDataMode(oldMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>（例子分析：此时新写入任何数据，还是<code>ac ed 00 05</code>，按照示例代码，接下来会进入writeOrdinaryObject方法）</p>
<h5 id="补充：ObjectStreamClass"><a href="#补充：ObjectStreamClass" class="headerlink" title="补充：ObjectStreamClass"></a>补充：ObjectStreamClass</h5><p>在上面writeObject0代码，创建了一个用于类序列化描述符的ObjectStreamClass对象，我们先大体分析下ObjectStreamClass。</p>
<p>官方文档是这样描述这个类的：</p>
<blockquote>
<p>类的序列化描述符。 它包含该类的名称和serialVersionUID。  以使用lookup方法查找/创建Java Java中加载的特定类的ObjectStreamClass。 </p>
</blockquote>
<p>除了内部类外它具有以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">forClass()：返回此版本映射到的本地VM中的类。</span><br><span class="line">getField(String name)：通过名称获取此类的字段。</span><br><span class="line">getFields()：返回此可序列化类的字段数组。</span><br><span class="line">getName()：返回此描述符描述的类的名称。</span><br><span class="line">getSerialVersionUID()：返回此类的serialVersionUID。</span><br><span class="line">lookup(类&lt;?&gt; cl)：找到可以序列化的类的描述符。</span><br><span class="line">lookupAny(类&lt;?&gt; cl)：返回任何类的描述符，无论它是否实现Serializable。</span><br><span class="line">toString()：返回描述此ObjectStreamClass的字符串。</span><br></pre></td></tr></table></figure>

<p>通过以上方法ObjectStreamClass对象可以获取Class、类名称、类属性数组、类的serialVersionUID等。</p>
<p>了解了ObjectStreamClass，继续回到我们的分析。</p>
<h5 id="三种类型的序列化-write-String-Array-Enum-："><a href="#三种类型的序列化-write-String-Array-Enum-：" class="headerlink" title="三种类型的序列化  write[String|Array|Enum]："></a>三种类型的序列化  write[String|Array|Enum]：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写字符串到底层流即字符串的序列化：格式 类型标识0x74/0x7C+内容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeString</span><span class="params">(String str, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : str);</span><br><span class="line">    <span class="keyword">long</span> utflen = bout.getUTFLength(str);</span><br><span class="line">    <span class="comment">// 长度小于 0xFFFF(65506)</span></span><br><span class="line">    <span class="keyword">if</span> (utflen &lt;= <span class="number">0xFFFF</span>) &#123;</span><br><span class="line">        bout.writeByte(TC_STRING); <span class="comment">//写标识0x74</span></span><br><span class="line">        bout.writeUTF(str, utflen); <span class="comment">//writeUTF写长度+内容</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bout.writeByte(TC_LONGSTRING);<span class="comment">//写标识0x7C</span></span><br><span class="line">        bout.writeLongUTF(str, utflen);<span class="comment">//长度+写内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 写数组到底层流 即数组的序列化</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeArray</span><span class="params">(Object array, ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        bout.writeByte(TC_ARRAY); <span class="comment">//写标识0x75 </span></span><br><span class="line">        writeClassDesc(desc, <span class="keyword">false</span>); <span class="comment">//写描述符</span></span><br><span class="line">        handles.assign(unshared ? <span class="keyword">null</span> : array);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; ccl = desc.forClass().getComponentType();</span><br><span class="line">     	<span class="comment">//处理基元数据的数组，格式：TC_ARRAY+描述符+长度+基元数据值的byte</span></span><br><span class="line">        <span class="keyword">if</span> (ccl.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ccl == Integer.TYPE) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] ia = (<span class="keyword">int</span>[]) array;</span><br><span class="line">                bout.writeInt(ia.length); <span class="comment">//写长度 </span></span><br><span class="line">                bout.writeInts(ia, <span class="number">0</span>, ia.length); <span class="comment">//写一组int值，将int转为byte</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl == Byte.TYPE) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] ba = (<span class="keyword">byte</span>[]) array;</span><br><span class="line">                bout.writeInt(ba.length);</span><br><span class="line">                bout.write(ba, <span class="number">0</span>, ba.length, <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl == Long.TYPE) &#123;</span><br><span class="line">                <span class="keyword">long</span>[] ja = (<span class="keyword">long</span>[]) array;</span><br><span class="line">                bout.writeInt(ja.length);</span><br><span class="line">                bout.writeLongs(ja, <span class="number">0</span>, ja.length);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl == Float.TYPE) &#123;</span><br><span class="line">                <span class="keyword">float</span>[] fa = (<span class="keyword">float</span>[]) array;</span><br><span class="line">                bout.writeInt(fa.length);</span><br><span class="line">                bout.writeFloats(fa, <span class="number">0</span>, fa.length);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl == Double.TYPE) &#123;</span><br><span class="line">                <span class="keyword">double</span>[] da = (<span class="keyword">double</span>[]) array;</span><br><span class="line">                bout.writeInt(da.length);</span><br><span class="line">                bout.writeDoubles(da, <span class="number">0</span>, da.length);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl == Short.TYPE) &#123;</span><br><span class="line">                <span class="keyword">short</span>[] sa = (<span class="keyword">short</span>[]) array;</span><br><span class="line">                bout.writeInt(sa.length);</span><br><span class="line">                bout.writeShorts(sa, <span class="number">0</span>, sa.length);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl == Character.TYPE) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] ca = (<span class="keyword">char</span>[]) array;</span><br><span class="line">                bout.writeInt(ca.length);</span><br><span class="line">                bout.writeChars(ca, <span class="number">0</span>, ca.length);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ccl == Boolean.TYPE) &#123;</span><br><span class="line">                <span class="keyword">boolean</span>[] za = (<span class="keyword">boolean</span>[]) array;</span><br><span class="line">                bout.writeInt(za.length);</span><br><span class="line">                bout.writeBooleans(za, <span class="number">0</span>, za.length);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//非基元数据数组,根据数组长度循环调用writeObject0</span></span><br><span class="line">            Object[] objs = (Object[]) array;</span><br><span class="line">            <span class="keyword">int</span> len = objs.length;</span><br><span class="line">            bout.writeInt(len); <span class="comment">//写数组长度</span></span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.push(</span><br><span class="line">                    <span class="string">"array (class \""</span> + array.getClass().getName() +</span><br><span class="line">                    <span class="string">"\", size: "</span> + len  + <span class="string">")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                        debugInfoStack.push(</span><br><span class="line">                            <span class="string">"element of array (index: "</span> + i + <span class="string">")"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//调用writeObject0处理对象的写入</span></span><br><span class="line">                        writeObject0(objs[i], <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                            debugInfoStack.pop();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    debugInfoStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写枚举类型的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeEnum</span><span class="params">(Enum&lt;?&gt; en,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ObjectStreamClass desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        bout.writeByte(TC_ENUM);<span class="comment">//写标识0x7E</span></span><br><span class="line">        ObjectStreamClass sdesc = desc.getSuperDesc();</span><br><span class="line">        writeClassDesc((sdesc.forClass() == Enum.class) ? desc : sdesc, false);</span><br><span class="line">        handles.assign(unshared ? <span class="keyword">null</span> : en);</span><br><span class="line">        writeString(en.name(), <span class="keyword">false</span>); <span class="comment">//写枚举名称以字符串形式序列化</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="序列化关键部分writeOrdinaryObject："><a href="#序列化关键部分writeOrdinaryObject：" class="headerlink" title="序列化关键部分writeOrdinaryObject："></a>序列化关键部分writeOrdinaryObject：</h5><p>Java 序列化普通对象保存了三部分的数据：类型信息序列化TC_OBJECT + 类信息序列化 writeClassDesc() + 类实例数据信息序列化。到这里终于可以看到 io 序列化流的操作了。这个方法主要是在 Externalizable 和 Serializable 的接口出现分支，如果实现了 Externalizable 接口并且类描述符非动态代理，则执行 writeExternalData，否则执行 writeSerialData。同时，这个方法会写类描述信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeOrdinaryObject</span><span class="params">(Object obj, ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack.push(</span><br><span class="line">            (depth == <span class="number">1</span> ? <span class="string">"root "</span> : <span class="string">""</span>) + <span class="string">"object (class \""</span> +</span><br><span class="line">            obj.getClass().getName() + <span class="string">"\", "</span> + obj.toString() + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        desc.checkSerialize();</span><br><span class="line">        <span class="comment">//写入类型TC_OBJECT 0x73，标识接下来数据是一个新的对象</span></span><br><span class="line">        bout.writeByte(TC_OBJECT); </span><br><span class="line">        <span class="comment">//写入类信息(类元信息写入结束的标志是TC_ENDBLOCKDATA 0x78，具体参考下一部分writeClassDesc的分析)</span></span><br><span class="line">        writeClassDesc(desc, <span class="keyword">false</span>);</span><br><span class="line">        handles.assign(unshared ? <span class="keyword">null</span> : obj);</span><br><span class="line">        <span class="comment">// 写入类实例数据</span></span><br><span class="line">        <span class="comment">// Externalizable或者动态代理调用writeExternalData，否则调用writeSerialData</span></span><br><span class="line">        <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">            <span class="comment">// 实现Externalizable接口的类对象的序列化</span></span><br><span class="line">            writeExternalData((Externalizable) obj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 实现Serializable接口的类对象的序列化</span></span><br><span class="line">            writeSerialData(obj, desc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（例子分析：加入<code>TC_OBJECT</code> <code>0x73</code>，当前流为<code>ac ed 00 05 73</code>，接下来调用writeClassDesc来写入类信息）</p>
<p>为了方便阅读，下面将根据两部分进行解析，一是类信息序列化 writeClassDesc()，一是类实例数据信息序列化writeExternalData/ writeSerialData。</p>
<h4 id="4-2、类元信息序列化-writeClassDesc"><a href="#4-2、类元信息序列化-writeClassDesc" class="headerlink" title="4.2、类元信息序列化 writeClassDesc()"></a>4.2、类元信息序列化 writeClassDesc()</h4><h5 id="writeClassDesc-序列化类信息："><a href="#writeClassDesc-序列化类信息：" class="headerlink" title="writeClassDesc-序列化类信息："></a>writeClassDesc-序列化类信息：</h5><p>writeClassDesc序列化类信息，序列化时会先递归调用 writeClassDesc 方法，将实现 Serializable 接口的父类信息也会同时序列化。类信息都保存在 ObjectStreamClass 类中，同时也可以通过 ObjectStreamClass#getFields 获取所有要序列的字段信息 ObjectStreamField。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将给定类描述符的表示形式写入流</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeClassDesc</span><span class="params">(ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> handle;</span><br><span class="line">    <span class="keyword">if</span> (desc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        writeNull();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!unshared &amp;&amp; (handle = handles.lookup(desc)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        writeHandle(handle);  <span class="comment">// 类信息已经序列化，则保存句柄即可</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (desc.isProxy()) &#123; <span class="comment">// 动态代理类信息序列化</span></span><br><span class="line">        writeProxyDesc(desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 非代理类信息序列化</span></span><br><span class="line">        writeNonProxyDesc(desc, unshared); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将表示标准(非动态代理)类的类描述符写入流。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeNonProxyDesc</span><span class="params">(ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bout.writeByte(TC_CLASSDESC); <span class="comment">//写0x72，代表一个新的类描述符</span></span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : desc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocol == PROTOCOL_VERSION_1) &#123;</span><br><span class="line">        <span class="comment">// do not invoke class descriptor write hook with old protocol</span></span><br><span class="line">        desc.writeNonProxy(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 写入类信息，本质上也是调用 desc.writeNonProxy(this)</span></span><br><span class="line">        writeClassDescriptor(desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="comment">//刷新块数据</span></span><br><span class="line">    bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span> &amp;&amp; isCustomSubclass()) &#123;</span><br><span class="line">        ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">    &#125;</span><br><span class="line">    annotateClass(cl);</span><br><span class="line">    bout.setBlockDataMode(<span class="keyword">false</span>); </span><br><span class="line">    <span class="comment">//注意这里有一个块数据结束标识的写入 TC_ENDBLOCKDATA 0x78</span></span><br><span class="line">    bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line"></span><br><span class="line">    writeClassDesc(desc.getSuperDesc(), <span class="keyword">false</span>); <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（例子分析：加入<code>TC_CLASSDESC</code> <code>0x72</code>，当前流为<code>ac ed 00 05 73 72</code>，接下来调用writeNonProxy来写入类信息）</p>
<h5 id="ObjectStreamClass-writeNonProxy：写入实际的类元信息"><a href="#ObjectStreamClass-writeNonProxy：写入实际的类元信息" class="headerlink" title="ObjectStreamClass#writeNonProxy：写入实际的类元信息"></a>ObjectStreamClass#writeNonProxy：写入实际的类元信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将非代理类描述符信息写入给定的输出流。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeNonProxy</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.writeUTF(name); <span class="comment">//写入类的名字 (例子分析：写入serial.TestSerializable，writeUTF会先写入长度再写字符串，长度为23 0x0017，serial.TestSerializable十六进制是`73 65 72 69 61 6c 2e 54 65 73 74 53 65 72 69 61  6c 69 7a 61 62 6c 65`，所以这里写入`00 17 73 65 72 69 61 6c 2e 54 65 73 74 53 65 72 69 61  6c 69 7a 61 62 6c 65`)</span></span><br><span class="line">    out.writeLong(getSerialVersionUID()); <span class="comment">//写入类的序列号 (例子分析：写入-6211228684695072792L的十六进制`a9 cd 48 6b 76 08 8f e8`，可以用Long.toHexString(l)本地输出下Long的十六进制)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (externalizable) &#123;</span><br><span class="line">        <span class="comment">// externalizable子类，获取SC_EXTERNALIZABLE 0x04</span></span><br><span class="line">        flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;</span><br><span class="line">        <span class="keyword">int</span> protocol = out.getProtocolVersion();</span><br><span class="line">        <span class="keyword">if</span> (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) &#123;</span><br><span class="line">            flags |= ObjectStreamConstants.SC_BLOCK_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializable) &#123;</span><br><span class="line">        <span class="comment">// serializable子类，获取SC_SERIALIZABLE 0x02</span></span><br><span class="line">        flags |= ObjectStreamConstants.SC_SERIALIZABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasWriteObjectData) &#123;</span><br><span class="line">        <span class="comment">// 类自定义了writeObject()，获取SC_WRITE_METHOD 0x01</span></span><br><span class="line">        flags |= ObjectStreamConstants.SC_WRITE_METHOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEnum) &#123;</span><br><span class="line">        <span class="comment">// 该类是枚举类型，获取SC_ENUM 0x10</span></span><br><span class="line">        flags |= ObjectStreamConstants.SC_ENUM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入类的flags  (例子分析：写入SC_SERIALIZABLE 0x02)</span></span><br><span class="line">    out.writeByte(flags); </span><br><span class="line">	<span class="comment">// 写入对象属性的个数 (例子分析：本例除了serialVersionUID有5个属性，写入0x0005，serialVersionUID是static类型不被计入，并且已经在前面写入了)</span></span><br><span class="line">    out.writeShort(fields.length); </span><br><span class="line">    <span class="comment">// 循环序列化每个属性的信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 创建一个类的可序列化属性字段描述的实例。ObjectStreamFields的数组用于声明一个类的可序列化属性。 </span></span><br><span class="line">        ObjectStreamField f = fields[i];</span><br><span class="line">        <span class="comment">// 写入第i个属性的类型，具体参考下一部分“补充：ObjectStreamField”的分析</span></span><br><span class="line">        out.writeByte(f.getTypeCode());<span class="comment">// (例子分析：有五个属性，3个是原生类型，2个是非原生，按照对应关系本例是intField写入I，boolField写入Z，shortField写入S,stringField写入L,fileField写入L)</span></span><br><span class="line">        <span class="comment">// 写入类型的长度+类名称</span></span><br><span class="line">        out.writeUTF(f.getName()); <span class="comment">//(例子分析：写入每个属性的长度和名称)</span></span><br><span class="line">        <span class="comment">// 如果属性类型不是Java原生类型，调用writeTypeString写入表示对象或者类的类型字符串</span></span><br><span class="line">        <span class="keyword">if</span> (!f.isPrimitive()) &#123;</span><br><span class="line">            <span class="comment">// f.getTypeString()=`Ljava/io/File;`（具体参考下一部分“补充：ObjectStreamField”的分析）</span></span><br><span class="line">            <span class="comment">// writeTypeString会调用writeString，写入0x74+长度+Ljava/io/File;</span></span><br><span class="line">            out.writeTypeString(f.getTypeString());<span class="comment">//(例子分析：写入两个非原生属性的类型`Ljava/io/File;`、`a/lang/String;`)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面代码可以看出，writeNonProxy主要作用是写入类信息和属性信息，具体会写入类长度+类名称+SerialVersionUID+类本身序列化的接口类型如SC_SERIALIZABLE+属性个数+每个属性信息</p>
<p>（例子分析：不算属性信息截至目前写入<code>ac ed 00 05 73 72 00 17 73 65 72 69 61 6c 2e 54 65 73 74 53 65 72 69 61  6c 69 7a 61 62 6c 65 a9 cd 48 6b 76 08 8f e8 02 00 05</code>。接下来分析循环属性完成写属性的信息，循环写入5个属性信息，分别是intField：I+长度0x0008+intField 即 <code>49 00  08 69 6e 74 46 69 65 6c 64</code>，boolField：Z+属性长度<code>0x0009</code>+boolField 即<code>5a 00 09 62 6f 6f 6c 46 69 65 6c 64</code>，shortField：S+长度0x000a+shortField 即 <code>53 00 0a 73 68 6f 72 74 46 69 65 6c 64</code>，fileField：L+属性名长度0x0009+fileField+TC_STRING + 类型长度0x0012+Ljava/io/File; 即 <code>4c 00 09 66 69 6c 65 46 69 65 6c 64 74 00 0e 4c 6a 61 76 61 2f 69 6f 2f 46 69  6c 65 3b</code>，stringField：L+长度0x000b+stringField+TC_STRING + 类型长度0x0012+Ljava/lang/String; 即 <code>4c 00 0b 73 74 72 69 6e 67 46 69 65 6c 64 74 00 12 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53  74 72 69 6e 67 3b</code>。因为原生类型属性信息和非原生类型属性信息位置是不一定的，所以属性信息在流的拼接后的具体信息不能确定。，最后不能忘了加上数据块结束标识TC_ENDBLOCKDATA 0x78)</p>
<h5 id="补充：ObjectStreamField"><a href="#补充：ObjectStreamField" class="headerlink" title="补充：ObjectStreamField"></a>补充：ObjectStreamField</h5><p>在上面writeNonProxy序列化类属性信息时，创建了一个用于类的可序列化属性字段描述的ObjectStreamField实例，我们先大体分析下它。</p>
<p>官方文档是这样描述这个类的：</p>
<blockquote>
<p>类的可序列化属性的描述。ObjectStreamFields的数组用于声明一个类的可序列化字段。 </p>
</blockquote>
<p>除了内部类外它具有以下public方法，通过以下方法可以获取某个属性的名称、类型等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">compareTo(Object obj)：将此字段与另一个 ObjectStreamField进行比较。</span><br><span class="line">getName()：获取此字段的名称。</span><br><span class="line">getOffset()：实例数据内的字段偏移量。</span><br><span class="line">getType()：获取字段的类型。</span><br><span class="line">getTypeCode()：返回字段类型的字符编码。</span><br><span class="line">getTypeString()：返回JVM类型签名。</span><br><span class="line">isPrimitive()：如果此字段具有原始类型，则返回<span class="keyword">true</span>。</span><br><span class="line">isUnshared()：返回指示此ObjectStreamField实例表示的可序列化字段是否未共享的布尔值。</span><br><span class="line">setOffset(<span class="keyword">int</span> offset)：实例数据偏移。</span><br></pre></td></tr></table></figure>

<p>除了上面的方法，还有一些需要特别关注的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在ObjectStreamField的构造函数中，将signature赋值属性的类型码，signature是字段类型的规范JVM签名。另外在getTypeCode的注释中也说明了类型码的对应关系。</span></span><br><span class="line"><span class="comment">/** 类型码对应关系</span></span><br><span class="line"><span class="comment">  * Z -&gt; boolean</span></span><br><span class="line"><span class="comment">  * B -&gt; byte</span></span><br><span class="line"><span class="comment">  * C -&gt; char</span></span><br><span class="line"><span class="comment">  * S -&gt; short</span></span><br><span class="line"><span class="comment">  * I -&gt; int</span></span><br><span class="line"><span class="comment">  * J -&gt; long</span></span><br><span class="line"><span class="comment">  * F -&gt; float</span></span><br><span class="line"><span class="comment">  * D -&gt; double</span></span><br><span class="line"><span class="comment">  * L -&gt; class or interface</span></span><br><span class="line"><span class="comment">  * [ -&gt; array</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">ObjectStreamField(Field field, <span class="keyword">boolean</span> unshared, <span class="keyword">boolean</span> showType) &#123;</span><br><span class="line">    <span class="keyword">this</span>.field = field;</span><br><span class="line">    <span class="keyword">this</span>.unshared = unshared;</span><br><span class="line">    name = field.getName();</span><br><span class="line">    Class&lt;?&gt; ftype = field.getType();</span><br><span class="line">    type = (showType || ftype.isPrimitive()) ? ftype : Object<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    <span class="comment">// 调用getClassSignature返回属性的类型码</span></span><br><span class="line">    signature = getClassSignature(ftype).intern();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性的类型码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getClassSignature</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">    StringBuilder sbuf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (cl.isArray()) &#123;</span><br><span class="line">        sbuf.append(<span class="string">'['</span>);</span><br><span class="line">        cl = cl.getComponentType();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cl.isPrimitive()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cl == Integer.TYPE) &#123;</span><br><span class="line">            sbuf.append(<span class="string">'I'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl == Byte.TYPE) &#123;</span><br><span class="line">            sbuf.append(<span class="string">'B'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl == Long.TYPE) &#123;</span><br><span class="line">            sbuf.append(<span class="string">'J'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl == Float.TYPE) &#123;</span><br><span class="line">            sbuf.append(<span class="string">'F'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl == Double.TYPE) &#123;</span><br><span class="line">            sbuf.append(<span class="string">'D'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl == Short.TYPE) &#123;</span><br><span class="line">            sbuf.append(<span class="string">'S'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl == Character.TYPE) &#123;</span><br><span class="line">            sbuf.append(<span class="string">'C'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl == Boolean.TYPE) &#123;</span><br><span class="line">            sbuf.append(<span class="string">'Z'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl == Void.TYPE) &#123;</span><br><span class="line">            sbuf.append(<span class="string">'V'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 特别注意 这里L返回的是L+类名（将.替换为/）+“;”，例如java.io对应是“Ljava/io;”</span></span><br><span class="line">        sbuf.append(<span class="string">'L'</span> + cl.getName().replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">';'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sbuf.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要处理非原生类型，非原生类型返回类型字符串为JVM type signature</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTypeString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isPrimitive() ? <span class="keyword">null</span> : signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>截止到这里，类元信息已经序列化完成，接下来序列化类实例数据信息，即属性具体值的序列化。</p>
<h4 id="4-3、类实例数据信息序列化writeExternalData-writeSerialData"><a href="#4-3、类实例数据信息序列化writeExternalData-writeSerialData" class="headerlink" title="4.3、类实例数据信息序列化writeExternalData/ writeSerialData"></a>4.3、类实例数据信息序列化writeExternalData/ writeSerialData</h4><h5 id="writeSerialData-amp-writeExternalData："><a href="#writeSerialData-amp-writeExternalData：" class="headerlink" title="writeSerialData&amp;writeExternalData："></a>writeSerialData&amp;writeExternalData：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为给定对象的每个可序列化类写入实例数据，从父类到子类。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 首先获取需要序列化的类(desc.getClassDataLayout())</span></span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        ObjectStreamClass slotDesc = slots[i].desc;</span><br><span class="line">        <span class="comment">//自定义writeObject方法</span></span><br><span class="line">        <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">            PutFieldImpl oldPut = curPut;</span><br><span class="line">            curPut = <span class="keyword">null</span>;</span><br><span class="line">            SerialCallbackContext oldContext = curContext;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.push(</span><br><span class="line">                    <span class="string">"custom writeObject data (class \""</span> +</span><br><span class="line">                    slotDesc.getName() + <span class="string">"\")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line">                <span class="comment">// 刷新数据流</span></span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">//调用自定义方法</span></span><br><span class="line">                slotDesc.invokeWriteObject(obj, <span class="keyword">this</span>);</span><br><span class="line">                bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">                bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                curContext.setUsed();</span><br><span class="line">                curContext = oldContext;</span><br><span class="line">                <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                    debugInfoStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            curPut = oldPut;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 未自定义writeObject 默认调用属性数据序列化方法defaultWriteFields</span></span><br><span class="line">            defaultWriteFields(obj, slotDesc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现了Externalizable的类实例用writeExternalData来序列化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeExternalData</span><span class="params">(Externalizable obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    PutFieldImpl oldPut = curPut;</span><br><span class="line">    curPut = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        debugInfoStack.push(<span class="string">"writeExternal data"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    SerialCallbackContext oldContext = curContext;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        curContext = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 调用重写的writeExternal()方法</span></span><br><span class="line">        <span class="keyword">if</span> (protocol == PROTOCOL_VERSION_1) &#123;</span><br><span class="line">            obj.writeExternal(<span class="keyword">this</span>); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">            obj.writeExternal(<span class="keyword">this</span>);</span><br><span class="line">            bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">            bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        curContext = oldContext;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curPut = oldPut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="属性值信息序列化的关键-默认属性值序列化方法defaultWriteFields"><a href="#属性值信息序列化的关键-默认属性值序列化方法defaultWriteFields" class="headerlink" title="属性值信息序列化的关键-默认属性值序列化方法defaultWriteFields:"></a>属性值信息序列化的关键-默认属性值序列化方法defaultWriteFields:</h5><p>defaultWriteFields读取目标类中的属性值域，属性值是原生类型直接序列化到底层流，而非原生类型则需要递归调用writeObject0 来序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defaultWriteFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span> &amp;&amp; obj != <span class="keyword">null</span> &amp;&amp; !cl.isInstance(obj)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    desc.checkDefaultSerialize();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*** 1、 Java 原生类型属性值序列化 **/</span></span><br><span class="line">    <span class="keyword">int</span> primDataSize = desc.getPrimDataSize(); <span class="comment">// 获取原生类型属性值的个数</span></span><br><span class="line">    <span class="keyword">if</span> (primVals == <span class="keyword">null</span> || primVals.length &lt; primDataSize) &#123;</span><br><span class="line">        primVals = <span class="keyword">new</span> <span class="keyword">byte</span>[primDataSize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取类中的基本数据类型的数据并保存在primVals字节数组中</span></span><br><span class="line">    desc.getPrimFieldValues(obj, primVals);</span><br><span class="line">    <span class="comment">// primVals的基本类型数据写到底层字节容器</span></span><br><span class="line">    bout.write(primVals, <span class="number">0</span>, primDataSize, <span class="keyword">false</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*** 2、 Java对象类型序列化，递归调用writeObject0 方法 **/</span></span><br><span class="line">    <span class="comment">// 获取对应类的所有字段对象</span></span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(<span class="keyword">false</span>);</span><br><span class="line">    Object[] objVals = <span class="keyword">new</span> Object[desc.getNumObjFields()];</span><br><span class="line">    <span class="keyword">int</span> numPrimFields = fields.length - objVals.length;</span><br><span class="line">    <span class="comment">// 获取所有对象的属性值</span></span><br><span class="line">    desc.getObjFieldValues(obj, objVals); </span><br><span class="line">    <span class="comment">//对所有Object类型的字段循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.push(</span><br><span class="line">                <span class="string">"field (class \""</span> + desc.getName() + <span class="string">"\", name: \""</span> +</span><br><span class="line">                fields[numPrimFields + i].getName() + <span class="string">"\", type: \""</span> +</span><br><span class="line">                fields[numPrimFields + i].getType() + <span class="string">"\")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeObject0(objVals[i], fields[numPrimFields + i].isUnshared()); <span class="comment">//递归完成序列化</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对单独分析下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">desc.getPrimFieldValues(obj, primVals); <span class="comment">// 循环所有原生属性值的序列化</span></span><br><span class="line">bout.write(primVals, <span class="number">0</span>, primDataSize, <span class="keyword">false</span>); <span class="comment">// 原生类型序列化</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrimFieldValues</span><span class="params">(Object obj, <span class="keyword">byte</span>[] buf)</span> </span>&#123;</span><br><span class="line">    fieldRefl.getPrimFieldValues(obj, buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ObjectStreamClass#getPrimFieldValues</span></span><br><span class="line"><span class="comment">// 循环所有原生属性值的序列化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrimFieldValues</span><span class="params">(Object obj, <span class="keyword">byte</span>[] buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环基元数据的类型的序列化：根据类型循环写入属性值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numPrimFields; i++) &#123;</span><br><span class="line">        <span class="keyword">long</span> key = readKeys[i];</span><br><span class="line">        <span class="keyword">int</span> off = offsets[i];</span><br><span class="line">        <span class="keyword">switch</span> (typeCodes[i]) &#123; <span class="comment">//（例子分析：本例typeCodes[i]是&#123;Z、I、S、L、L&#125;，需要跟前面属性名顺序对应，比如boolField在第一个，其值在该块也是第一个）</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Z'</span>:</span><br><span class="line">                <span class="comment">//（例子分析：写入boolField值Fales，0x00</span></span><br><span class="line">                Bits.putBoolean(buf, off, unsafe.getBoolean(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">                buf[off] = unsafe.getByte(obj, key);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">                Bits.putChar(buf, off, unsafe.getChar(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">                <span class="comment">//（例子分析：写入shortField值12，0x000c</span></span><br><span class="line">                Bits.putShort(buf, off, unsafe.getShort(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">                <span class="comment">//（例子分析：写入intField值112，0x00000070</span></span><br><span class="line">                Bits.putInt(buf, off, unsafe.getInt(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'F'</span>:</span><br><span class="line">                Bits.putFloat(buf, off, unsafe.getFloat(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'J'</span>:</span><br><span class="line">                Bits.putLong(buf, off, unsafe.getLong(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">                Bits.putDouble(buf, off, unsafe.getDouble(obj, key));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（例子分析：第三部分属性值域序列化，按照之前每个属性信息序列化的顺序来写入其对应值，非原生属性值本例是<code>00 00 00 00 70  00 0c</code>，写入非原生类型的属性值，这里不再说明，自行调试）</p>
<h3 id="六、总结-对象流输出规则"><a href="#六、总结-对象流输出规则" class="headerlink" title="六、总结-对象流输出规则"></a>六、总结-对象流输出规则</h3><p><img src="/imgs/image-20210701160611733.png" alt="image-20210701160611733"></p>
<p>1、首先在序列化对象时，把序列化对象的信息分为三部分来存储，如上图：</p>
<ul>
<li><p>第一部分是序列化头信息：用于描述序列化协议的信息和版本；</p>
</li>
<li><p>第二部分是类元信息的序列化：用于描述序列化类的名称，属性和父类的名称、属性；</p>
</li>
<li><p>第三部分是属性域的值的描述：用于记录当前类中属性的值。</p>
</li>
</ul>
<p>2、第二部分描述的规则如下：<br>（1）首先声明标记的是TC_OBJECT = 0x73；<br>（2）接下来声明一个新类的描述TC_CLASSDESC = 0x72，写入目标类名长度、类名、序列化ID、标记该类使用的序列化方式；<br>（3）然后标记类属性域的个数、属性类型、属性名称长度、属性名称，如果是非原生类型还有写入类的非原生类型长度和名称<br>（4）添加标记对象数据块结束标识TC_ENDBLOCKDATA  = 0x78<br>（5）然后开始父类的描述，标记的方式和前面一致，当再没有新的父类时，添加标记TC_NULL  = 0x70<br>另外再提下，目标类本身的类名描述是以”java.io”形式 而如果是属性的非原生类型类名是以”Ljava/io;”标注的，一个是”.”一个是”/“。</p>
<p>3、第三部分的描述规则：<br>按照从父类到子类的顺序填充属性域的实际值，而对象的属性按照从基本数据类型到对象类型的顺序填充实际值。</p>
<p>4、在第二部分和第三部分都采用了递归的方式进行填充。</p>
<p>另外，Java序列化永远只会<strong>对类属性序列化</strong>，因为我们只要知道了类的全称，那么方法在内部都一样的，只管去调用就好了；在ObjectOutputStream中专门有一个内部类去处理原生类型的写入，所有的非原生类最终都是由原生类型组成的，非原生类归根结底还是原生类型，<strong>所以最终还是落到原生类型的序列化上面</strong>。</p>
<h3 id="更新-defaultWriteObject"><a href="#更新-defaultWriteObject" class="headerlink" title="更新-defaultWriteObject"></a>更新-defaultWriteObject</h3><p>我们在一些类重写writeObject时经常看到会调用defaultWriteObject方法，这里补充下。</p>
<p>方法很简单，在块模式中调用defaultWriteFields写入目标对象的属性域信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultWriteObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SerialCallbackContext ctx = curContext;</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotActiveException(<span class="string">"not in call to writeObject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Object curObj = ctx.getObj();</span><br><span class="line">    ObjectStreamClass curDesc = ctx.getDesc();</span><br><span class="line">    bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">    defaultWriteFields(curObj, curDesc);</span><br><span class="line">    bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>defaultWriteFields具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">defaultWriteFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass(); <span class="comment">//类描述信息</span></span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span> &amp;&amp; obj != <span class="keyword">null</span> &amp;&amp; !cl.isInstance(obj)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    desc.checkDefaultSerialize();<span class="comment">//检查是否支持序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> primDataSize = desc.getPrimDataSize(); <span class="comment">//获取类中可序列化的属性的个数</span></span><br><span class="line">    <span class="keyword">if</span> (primVals == <span class="keyword">null</span> || primVals.length &lt; primDataSize) &#123;</span><br><span class="line">        primVals = <span class="keyword">new</span> <span class="keyword">byte</span>[primDataSize]; <span class="comment">//写入属性个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    desc.getPrimFieldValues(obj, primVals);</span><br><span class="line">    bout.write(primVals, <span class="number">0</span>, primDataSize, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(<span class="keyword">false</span>);</span><br><span class="line">    Object[] objVals = <span class="keyword">new</span> Object[desc.getNumObjFields()];</span><br><span class="line">    <span class="keyword">int</span> numPrimFields = fields.length - objVals.length;</span><br><span class="line">    desc.getObjFieldValues(obj, objVals);</span><br><span class="line">    <span class="comment">// 循环写入所有属性信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.push(</span><br><span class="line">                <span class="string">"field (class \""</span> + desc.getName() + <span class="string">"\", name: \""</span> +</span><br><span class="line">                fields[numPrimFields + i].getName() + <span class="string">"\", type: \""</span> +</span><br><span class="line">                fields[numPrimFields + i].getType() + <span class="string">"\")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用writeObject0写入每个属性对象</span></span><br><span class="line">            writeObject0(objVals[i],fields[numPrimFields + i].isUnshared());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">Java API 8</a><br><a href="https://www.cnblogs.com/yanggb/p/10664155.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanggb/p/10664155.html</a><br><a href="https://blog.csdn.net/jenny_995368/article/details/99672570" target="_blank" rel="noopener">https://blog.csdn.net/jenny_995368/article/details/99672570</a><br><a href="https://developer.aliyun.com/article/636145" target="_blank" rel="noopener">https://developer.aliyun.com/article/636145</a><br><a href="https://blog.csdn.net/weixin_33843947/article/details/89618157" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33843947/article/details/89618157</a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/download/">Download</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、DataOutput"><span class="toc-number">1.</span> <span class="toc-text">一、DataOutput</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、ObjectOutput"><span class="toc-number">2.</span> <span class="toc-text">二、ObjectOutput</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、OutputStream"><span class="toc-number">3.</span> <span class="toc-text">三、OutputStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、ObjectStreamConstants"><span class="toc-number">4.</span> <span class="toc-text">四、ObjectStreamConstants</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、ObjectOutputStream"><span class="toc-number">5.</span> <span class="toc-text">五、ObjectOutputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、静态内部类BlockDataOutputStream-Java基本数据类型的写入流实现"><span class="toc-number">5.1.</span> <span class="toc-text">1、静态内部类BlockDataOutputStream-Java基本数据类型的写入流实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1、BlockDataOutputStream构造方法："><span class="toc-number">5.1.1.</span> <span class="toc-text">1.1、BlockDataOutputStream构造方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2、块数据模式及底层流数据写入"><span class="toc-number">5.1.2.</span> <span class="toc-text">1.2、块数据模式及底层流数据写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3、BlockDataOutputStream处理基元数据输出方法："><span class="toc-number">5.1.3.</span> <span class="toc-text">1.3、BlockDataOutputStream处理基元数据输出方法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、序列化导读"><span class="toc-number">5.2.</span> <span class="toc-text">2、序列化导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、ObjectOutputStream构造方法"><span class="toc-number">5.3.</span> <span class="toc-text">3、ObjectOutputStream构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1、有参构造："><span class="toc-number">5.3.1.</span> <span class="toc-text">3.1、有参构造：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2、writeStreamHeader-："><span class="toc-number">5.3.2.</span> <span class="toc-text">3.2、writeStreamHeader()：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、writeObject写入对象输出流"><span class="toc-number">5.4.</span> <span class="toc-text">4、writeObject写入对象输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#writeObject的调用"><span class="toc-number">5.4.1.</span> <span class="toc-text">writeObject的调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1、writeObject："><span class="toc-number">5.4.2.</span> <span class="toc-text">4.1、writeObject：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#writeObject"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">writeObject</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#writeFatalException：处理序列化异常情况下的序列化信息"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">writeFatalException：处理序列化异常情况下的序列化信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#writeObject0："><span class="toc-number">5.4.2.3.</span> <span class="toc-text">writeObject0：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#补充：ObjectStreamClass"><span class="toc-number">5.4.2.4.</span> <span class="toc-text">补充：ObjectStreamClass</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三种类型的序列化-write-String-Array-Enum-："><span class="toc-number">5.4.2.5.</span> <span class="toc-text">三种类型的序列化  write[String|Array|Enum]：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#序列化关键部分writeOrdinaryObject："><span class="toc-number">5.4.2.6.</span> <span class="toc-text">序列化关键部分writeOrdinaryObject：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2、类元信息序列化-writeClassDesc"><span class="toc-number">5.4.3.</span> <span class="toc-text">4.2、类元信息序列化 writeClassDesc()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#writeClassDesc-序列化类信息："><span class="toc-number">5.4.3.1.</span> <span class="toc-text">writeClassDesc-序列化类信息：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ObjectStreamClass-writeNonProxy：写入实际的类元信息"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">ObjectStreamClass#writeNonProxy：写入实际的类元信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#补充：ObjectStreamField"><span class="toc-number">5.4.3.3.</span> <span class="toc-text">补充：ObjectStreamField</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3、类实例数据信息序列化writeExternalData-writeSerialData"><span class="toc-number">5.4.4.</span> <span class="toc-text">4.3、类实例数据信息序列化writeExternalData&#x2F; writeSerialData</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#writeSerialData-amp-writeExternalData："><span class="toc-number">5.4.4.1.</span> <span class="toc-text">writeSerialData&amp;writeExternalData：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#属性值信息序列化的关键-默认属性值序列化方法defaultWriteFields"><span class="toc-number">5.4.4.2.</span> <span class="toc-text">属性值信息序列化的关键-默认属性值序列化方法defaultWriteFields:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六、总结-对象流输出规则"><span class="toc-number">5.5.</span> <span class="toc-text">六、总结-对象流输出规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新-defaultWriteObject"><span class="toc-number">5.6.</span> <span class="toc-text">更新-defaultWriteObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考："><span class="toc-number">5.7.</span> <span class="toc-text">参考：</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&text=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&title=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&is_video=false&description=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流" target="_blank" rel="noopener"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流&body=Check out this article: https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&title=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流" target="_blank" rel="noopener"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&title=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流" target="_blank" rel="noopener"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&title=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流" target="_blank" rel="noopener"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&title=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流" target="_blank" rel="noopener"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&name=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://r17a-17.github.io/2021/06/28/JDK%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%BA%8C%EF%BC%9AObjectOutputStream%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81/&t=JDK序列化机制及源码解读二：ObjectOutputStream对象输出流" target="_blank" rel="noopener"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2020-2022
    R17a
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/download/">Download</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

    <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?05441306932d71b1dba39f817847ce3e";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

<!-- Disqus Comments -->


</body>
</html>
